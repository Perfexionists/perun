#include <iostream>
#include <fstream>
#include <string>
#include <unordered_map>
#include <sstream>
#include <set>
#include <vector>
#include "pin.H"

#define DYNAMIC_DATA_FILE "{{ dynamic_data_file }}"
#define STATIC_DATA_FILE "{{ static_data_file }}"

{%- if collect_arguments %}
#define FUNC_CNT {{ function_count }}
std::string function_names[FUNC_CNT] { {{ function_names }} };
{%- endif %}

PIN_MUTEX staticDataLock;
PIN_MUTEX dynamicDataLock;
std::ofstream dynamicData;
std::ofstream staticData;

{% include 'time-data-structures.jinja2' %}

SourceFilesMap sourceFiles;
{% if not collect_basic_blocks_only -%}
std::vector<RoutineMetadata> routines;
{% endif %}
{% if collect_basic_blocks or collect_basic_blocks_only -%}
std::unordered_map<ADDRINT, BasicBlockMetadata> basicBlocks;
{%- endif %}

// --- Auxiliary functions ---
bool isBlacklistedRoutine(RTN routine) {
    std::vector<std::string> prefixBlacklist = {"__", "_init", "_start", "_fini", "_GLOBAL__sub_I__",
                                                "frame_dummy", "register_tm_clones", "deregister_tm_clones",
                                                "std::ios_base::Init::Init"};
    std::string routineName = PIN_UndecorateSymbolName(RTN_Name(routine), UNDECORATION_NAME_ONLY);
    for (auto& prefix : prefixBlacklist) {
        if (routineName.rfind(prefix, 0) == 0) {
            return true;
        }
    }
    return false;
}

// --- Implementations of class methods ---
UINT32 SourceFilesMap::addFile(std::string file) {
    // TODO: reimplement this with only one search (emplace does another)
    auto sourceFileIterator = sourceFiles.find(file);

    if (sourceFileIterator == sourceFiles.end()) {
        sourceFiles.emplace(file.c_str(), this->sourceFileIdCounter);
        return this->sourceFileIdCounter++;
    } else {
        return sourceFileIterator->second;
    }
}

std::string SourceFilesMap::dumpMap() {
    std::stringstream dump;
    for (auto& fileInfo : this->sourceFiles) {
        dump << fileInfo.first << ";" << fileInfo.second << std::endl;
    }
    return dump.str();
}

SourceCodeLocation::SourceCodeLocation(INS instruction) {
    this->line = 0;
    this->column = 0;
    this->fileName= "";
    // NOTE: this implementation is suitable only for calls during instrumentation
    // because it does not obtain client lock (PIN_ClientLock). It should not be
    // called inside an analysis function.
    ADDRINT address = INS_Address(instruction);
    // NOTE: Requires debugging information in instrumented binary
    PIN_GetSourceLocation(address, &(this->column), &(this->line), &(this->fileName));
}

{% if not collect_basic_blocks_only %}
RoutineMetadata::RoutineMetadata(RTN routine) {
    this->address = RTN_Address(routine);
    this->name = PIN_UndecorateSymbolName(RTN_Name(routine), UNDECORATION_NAME_ONLY);

    // Retrieve information about location of the routine in the source code of the project.
    RTN_Open(routine);
    SourceCodeLocation startLocation(RTN_InsHead(routine));
    SourceCodeLocation endLocation(RTN_InsTail(routine));
    RTN_Close(routine);

    // Store start and end of the function definition
    this->locationBoundaries = std::make_pair(startLocation.line, endLocation.line);

    // Update the source files map with new file if needed
    // Note: A routine starts and ends in the same file therefore the endLocation
    // always contains the same file
    this->sourceCodeFileId = sourceFiles.addFile(startLocation.fileName);
}
{% endif %}

{% if collect_basic_blocks or collect_basic_blocks_only %}
BasicBlockMetadata::BasicBlockMetadata(BBL basicBlock) {
    this->address = BBL_Address(basicBlock);
    this->routineName = PIN_UndecorateSymbolName(RTN_Name(INS_Rtn(BBL_InsHead(basicBlock))), UNDECORATION_NAME_ONLY);
    this->instructionsCount = BBL_NumIns(basicBlock);
    this->isFunctionEnd = INS_IsRet(BBL_InsTail(basicBlock));

    // Gather the complete location of the basic block instructions
    // NOTE: The source code file is extracted from the first instruction
    INS ins = BBL_InsHead(basicBlock);
    SourceCodeLocation location(ins);
    std::set<INT32> uniqueLines;
    uniqueLines.insert(location.line);
    sourceCodeLines.push_back(location.line);

    // Update the source files map with new file if needed
    // Note: A routine starts and ends in the same file therefore the endLocation
    // always contains the same file
    this->sourceCodeFileId = sourceFiles.addFile(location.fileName);

    // Gather the rest of the lines from the remaining instructions
    for (ins = INS_Next(ins); INS_Valid(ins) ; ins = INS_Next(ins)) {
        // Only unique lines are inserted and the vector stays in order
        UINT32 line = SourceCodeLocation(ins).line;
        if (uniqueLines.insert(line).second) {
            sourceCodeLines.push_back(line);
        }
    }
}
{% endif %}


// Function is called when the application exits and cleans up the used resources.
VOID fini(INT32 code, VOID* v){

    // Dump additional repetitive information making the output more compact
    PIN_MutexLock(&staticDataLock);

    staticData << "#Files" << std::endl << sourceFiles.dumpMap();

    {% if not collect_basic_blocks_only %}
    staticData << "#Routines" << std::endl;
    UINT32 routineId = 0;  // The ID is based on the index in global routines vector
    for (auto& routineMetadata : routines) {
        staticData << routineId  // Routine ID
                   << ";" << routineMetadata.name  // Name of the routine
                   << ";" << routineMetadata.sourceCodeFileId  // Routine file location ID
                   << ";" << routineMetadata.locationBoundaries.first  // Routine location start line
                   << ";" << routineMetadata.locationBoundaries.second  // Routine location end line
                   << std::endl;
        routineId++;
    }
    {% endif %}

    {% if collect_basic_blocks or collect_basic_blocks_only %}
    staticData << "#Basic blocks" << std::endl;
    for (auto& basicBlock: basicBlocks) {
        staticData << basicBlock.first  // Basic block ID - address
                   << ";" << basicBlock.second.routineName  // Name of the routine the basic block belongs to
                   << ";" << basicBlock.second.instructionsCount  // Number of instructions in the basic block
                   << ";" << basicBlock.second.sourceCodeFileId;  // ID of file where is the basic block located
        for (auto& lineNumber : basicBlock.second.sourceCodeLines) {  // Lines that basic block maps to
            staticData << ";" << lineNumber;
        }
        staticData << std::endl;
    }
    {% endif -%}
    PIN_MutexUnlock(&staticDataLock);

    dynamicData.close();
    PIN_MutexFini(&dynamicDataLock);

    staticData.close();
    PIN_MutexFini(&staticDataLock);
}


{% include 'time-analysis.jinja2' %}

{% include 'time-instrumentation.jinja2' %}

{% include 'main.jinja2' %}