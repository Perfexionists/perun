{%- if collect_basic_blocks %}
{#- NOTE: Probed mode doesn't support lower granularity than routines, therefore this part doesn't need to handle probed mode differences #}
VOID instrumentBasicBlocksInTrace(TRACE trace, VOID *v) {
    RTN routine = TRACE_Rtn(trace);

    // Filter out trace based on the routine it belongs to
    if (!RTN_Valid(routine) or
        !IMG_Valid(SEC_Img(RTN_Sec(routine))) or
        !IMG_IsMainExecutable(SEC_Img(RTN_Sec(routine))) or
        RTN_IsDynamic(routine) or RTN_IsArtificial(routine) or
        isBlacklistedRoutine(routine)) { return; }

    BasicBlockMetadata basicBlockMetadata(TRACE_BblHead(trace));
    std::unordered_map<ADDRINT, BasicBlockMetadata>::const_iterator basicBlockIterator;
    ADDRINT basicBlockId;
    IPOINT ipointAfter;
    // Iterate over basic blocks in the trace
    for (BBL bbl = TRACE_BblHead(trace); BBL_Valid(bbl); bbl = BBL_Next(bbl)) {
        basicBlockId = BBL_Address(bbl);
        basicBlockMetadata = BasicBlockMetadata(bbl);
        basicBlockIterator = basicBlocks.insert(std::make_pair(basicBlockId, basicBlockMetadata)).first;
        // Instrument the first instruction of the basic block
        INS_InsertCall(BBL_InsHead(bbl), IPOINT_BEFORE, (AFUNPTR)basicBlockAnalysis,
                       IARG_FAST_ANALYSIS_CALL,
                       IARG_ADDRINT, basicBlockIterator->first,
                       IARG_THREAD_ID,
                       IARG_UINT32, Location::L_BEFORE,
                       IARG_UINT32, basicBlockIterator->second.isFunctionEnd,
                       IARG_END);


        ipointAfter = IPOINT_BEFORE;
{#        if (INS_IsValidForIpointAfter(BBL_InsTail(bbl))) {#}
{#            ipointAfter = IPOINT_AFTER;#}
{#        }#}
{#        if (INS_IsValidForIpointTakenBranch(BBL_InsTail(bbl))) {#}
{#            ipointAfter = IPOINT_TAKEN_BRANCH;#}
{#        }#}
        // Instrument the last instruction of the basic block
        INS_InsertCall(BBL_InsTail(bbl), ipointAfter, (AFUNPTR)basicBlockAnalysis,
                       IARG_FAST_ANALYSIS_CALL,
                       IARG_ADDRINT, basicBlockIterator->first,
                       IARG_THREAD_ID,
                       IARG_UINT32, Location::L_AFTER,
                       IARG_UINT32, basicBlockIterator->second.isFunctionEnd,
                       IARG_END);
    }
}
{% endif -%}

VOID instrumentRoutinesInImage(IMG img, VOID* v) {
    // Skip images that are not from main executable
    if (!IMG_IsMainExecutable(img)) { return; }

    UINT32 routineIndex = 0;

    // Iterate over sections in the image
    for (SEC sec = IMG_SecHead(img); SEC_Valid(sec); sec = SEC_Next(sec)) {
        // Iterate over routines in the section
        for (RTN routine = SEC_RtnHead(sec); RTN_Valid(routine); routine = RTN_Next(routine)) {

            // Filter out routines that should not be instrumented
            if (RTN_IsArtificial(routine) or{% if not probed %} RTN_IsDynamic(routine) or{% endif %}
                isBlacklistedRoutine(routine){% if probed %}or !RTN_IsSafeForProbedInsertion(routine){% endif %}) {
                continue;
            }

            // Store information about routine for the output
            RoutineMetadata routineMetadata(routine);
            // Skip routines where source file is not found
            if (routineMetadata.sourceCodeFileId == 0) { continue; }
            routines.push_back(routineMetadata);
            routineIndex = routines.size() - 1;

            {% if probed %}
            // FIXME: Here is the main problem with probed mode. A function prototype needs to be created for every
            // instrumented function however, providing arguments to this prototype is tricky due to limitations, such as no
            // support for floats. Documentation in this case is very vague and doesn't provide much information about PROTO
            // object and its use. For now the prototype is created as a dummy and output of probed mode isn't very
            // reliable, in some cases even there isn't even output.
            PROTO after_f = PROTO_Allocate(PIN_PARG(VOID), CALLINGSTD_DEFAULT, "routineAnalysis", PIN_PARG(NULL), PIN_PARG_END());
            {%- endif -%}

            // Instrument routine with before and after calls
            {% if not probed %}RTN_Open(routine);{% endif %}

            {% if collect_arguments -%}
            int found_in_table = 0;
            for (int i = 0; i < FUNC_CNT; i++) {
                if (function_names[i] == routineMetadata.name) {
                    // Function has arguments that need to be collected
                    found_in_table = 1;
                    // TODO: create an PARG lists for each function and index it by the i from for cycle. This should eliminate
                    // the need for so many ifs. The routine index needs to be added at this stage, however the lists can be
                    // pre-crafted as the global array of function names with arguments.
                    {% for function in function_arguments_info %}
                    if (routineMetadata.name == "{{ function.name }}") {
                        RTN_InsertCall{% if probed %}Probed{% endif %}(routine, IPOINT_BEFORE, (AFUNPTR)routineAnalysisBefore_{{ function.name }},
                                                                       IARG_FAST_ANALYSIS_CALL,
                                                                       IARG_UINT32, routineIndex,
                                                                       {% if not probed %}IARG_THREAD_ID,{% endif %}
                                                                       {%- for argument in function.arguments %}
                                                                       IARG_FUNCARG_ENTRYPOINT_REFERENCE, {{ argument.index }},
                                                                       {%- endfor %}
                                                                       IARG_END);
                        break; // found the function and instrumented it
                    }
                    {% endfor %}
                }
            }
            if (!found_in_table) { // The function does not require special arguments instrumentation
                RTN_InsertCall{% if probed %}Probed{% endif %}(routine, IPOINT_BEFORE, (AFUNPTR)routineAnalysis,
                                                               IARG_FAST_ANALYSIS_CALL,
                                                               IARG_UINT32, routineIndex,
                                                               {% if not probed %}IARG_THREAD_ID,{% endif %}
                                                               IARG_UINT32, Location::L_BEFORE,
                                                               IARG_END);
            }
            {% else %} {# Don't collect arguments #}
            RTN_InsertCall{% if probed %}Probed{% endif %}(routine, IPOINT_BEFORE, (AFUNPTR)routineAnalysis,
                                                           IARG_FAST_ANALYSIS_CALL,
                                                           IARG_UINT32, routineIndex,
                                                           {% if not probed %}IARG_THREAD_ID,{% endif %}
                                                           IARG_UINT32, Location::L_BEFORE,
                                                           IARG_END);
            {%- endif %}
            RTN_InsertCall{% if probed %}Probed{% endif %}(routine, IPOINT_AFTER, (AFUNPTR)routineAnalysis,
                           IARG_FAST_ANALYSIS_CALL,
                           {% if probed %}IARG_PROTOTYPE, after_f,{% endif %}
                           IARG_UINT32, routineIndex,
                           {% if not probed %}IARG_THREAD_ID,{% endif %}
                           IARG_UINT32, Location::L_AFTER,
                           IARG_END);

            {% if not probed %}RTN_Close(routine);{% endif %}
            {%- if probed %}PROTO_Free(after_f);{% endif %}
        }
    }
}

