// Function that executes every time a new routine is found during the execution of the program
VOID Routine(RTN rtn, VOID* v){
    // Determine if the routine is valid and should be instrumented
    if (IMG_IsMainExecutable(SEC_Img(RTN_Sec(rtn))) && RTN_Valid(rtn){% if not probed %} && !RTN_IsDynamic(rtn){% endif %} && !RTN_IsArtificial(rtn){% if probed %} && RTN_IsSafeForProbedInsertion(rtn){% endif %}) {
        std::string rtn_name = PIN_UndecorateSymbolName(RTN_Name(rtn), UNDECORATION_NAME_ONLY);
        if (rtn_name.rfind("__",0) == 0 || rtn_name.rfind("_GLOBAL__sub_I__",0) == 0){
            // Filter out internal functions. These functions don't need to be profiled and their filtration reduces size
            // of collected data as well as shortens the time required to parse this data.
            return;
        }

        // Store information about routine for the output
        RoutineInfo* rc = new RoutineInfo;
        rc->name = rtn_name;
        rc->id = RTN_Id(rtn);

        // Retrieve the location of the routine in the source code
        INT32 sourceCodeCol;
        PIN_LockClient();
        // Requires debugging information in instrumented binary
        PIN_GetSourceLocation(RTN_Address(rtn), &sourceCodeCol, &(rc->sourceCodeLine), &(rc->sourceCodeFile));
        PIN_UnlockClient();
        if (rc->sourceCodeFile == "") {
            // skip the functions since its location is not known
            return;
        }

        {% if probed %}
        // FIXME: Here is the main problem with probed mode. A function prototype needs to be created for every 
        // instrumented function however, providing arguments to this prototype is tricky due to limitations, such as no
        // support for floats. Documentation in this case is very vague and doesn't provide much information about PROTO
        // object and its use. For now the prototype is created as a dummy and output of probed mode isn't very
        // reliable, in some cases even there isn't even output.
        PROTO after_f = PROTO_Allocate(PIN_PARG(VOID), CALLINGSTD_DEFAULT, "rtn_analysis_after", PIN_PARG(RoutineInfo*), PIN_PARG_END());
        {%- endif -%}

        {% if not probed %}RTN_Open(rtn);{% endif %}

        {% if collect_arguments -%}
        int found_in_table = 0;
        for (int func_index = 0; func_index < FUNC_CNT; func_index++) {
            if (function_names[func_index] == rc->name) {
                // Function has arguments that need to be collected
                found_in_table = 1;
                {% for function in function_table %}
                if (rc->name == "{{ function.name }}") {
                    RTN_InsertCall{% if probed %}Probed{% endif %}(rtn, IPOINT_BEFORE, (AFUNPTR)rtn_analysis_before_{{ function.name }},
                                        IARG_PTR, rc,
                                        {%- if not probed %}IARG_THREAD_ID,{% endif %}
                                        {%- for argument in function.arguments %}
                                        IARG_FUNCARG_ENTRYPOINT_REFERENCE, {{ argument.index }},
                                        {%- endfor %}
                                        IARG_END);
                    break;
                }
                {% endfor %}
            }
        }
        if (!found_in_table) {
            RTN_InsertCall{% if probed %}Probed{% endif %}(rtn, IPOINT_BEFORE, (AFUNPTR)rtn_analysis_before, IARG_PTR, rc, {% if not probed %}IARG_THREAD_ID,{% endif %}IARG_END);
        }
        {% else %} {# Don't collect arguments #}
        RTN_InsertCall{% if probed %}Probed{% endif %}(rtn, IPOINT_BEFORE, (AFUNPTR)rtn_analysis_before, IARG_PTR, rc, {% if not probed %}IARG_THREAD_ID,{% endif %}IARG_END);
        {%- endif %}
        RTN_InsertCall{% if probed %}Probed{% endif %}(rtn, IPOINT_AFTER, (AFUNPTR)rtn_analysis_after, {% if probed %}IARG_PROTOTYPE, after_f, {% endif %}IARG_PTR, rc, {% if not probed %}IARG_THREAD_ID,{% endif %} IARG_END);

        {% if not probed %}RTN_Close(rtn);{% endif %}
        {%- if probed %}PROTO_Free(after_f);{% endif %}
    }
}


{%- if bbl %}
// Pin calls this function every time a new Trace is executed
VOID Trace(TRACE trace, VOID *v) {

    if (!RTN_Valid(TRACE_Rtn(trace)) || RTN_IsDynamic(TRACE_Rtn(trace)) ||
        RTN_IsArtificial(TRACE_Rtn(trace)) ||
        !IMG_Valid(SEC_Img(RTN_Sec(TRACE_Rtn(trace)))) ||
        !IMG_IsMainExecutable(SEC_Img(RTN_Sec(TRACE_Rtn(trace))))) {
        return;
    }
    std::string rtn_name = PIN_UndecorateSymbolName(RTN_Name(TRACE_Rtn(trace)), UNDECORATION_NAME_ONLY);
    if (rtn_name.rfind("__",0) == 0 || rtn_name.rfind("_GLOBAL__sub_I__",0) == 0){
        // Filter out internal functions. These functions don't need to be profiled and their filtration reduces size
        // of collected data as well as shortens the time required to parse this data.
        return;
    }

    BasicBlockInfo* basicBlockInfo = new BasicBlockInfo;
    basicBlockInfo->routineName = PIN_UndecorateSymbolName(RTN_Name(TRACE_Rtn(trace)), UNDECORATION_NAME_ONLY);
    basicBlockInfo->routineId = RTN_Id(TRACE_Rtn(trace));

    ADDRINT firstInstrAddr, lastInstrAddr;
    INT32 sourceCodeCol;

    for (BBL bbl = TRACE_BblHead(trace); BBL_Valid(bbl); bbl = BBL_Next(bbl)) {

        firstInstrAddr = INS_Address(BBL_InsHead(bbl));
        lastInstrAddr = INS_Address(BBL_InsTail(bbl));
        basicBlockInfo->id = firstInstrAddr;

        PIN_LockClient();
        // Requires debugging information in instrumented binary
        PIN_GetSourceLocation(lastInstrAddr, &sourceCodeCol, &(basicBlockInfo->sourceCodeLineEnd),
                                                             &(basicBlockInfo->sourceCodeFile));
        PIN_GetSourceLocation(firstInstrAddr, &sourceCodeCol, &(basicBlockInfo->sourceCodeLineStart),
                                                              &(basicBlockInfo->sourceCodeFile));
        PIN_UnlockClient();

        if (basicBlockInfo->sourceCodeFile == "") {
            // skip the basic block since its location is not known
            continue;
        }

        INS_InsertCall(BBL_InsHead(bbl), IPOINT_BEFORE, (AFUNPTR)bbl_analysis_before,
                       IARG_PTR, basicBlockInfo, IARG_THREAD_ID, IARG_END);
        INS_InsertCall(BBL_InsTail(bbl), IPOINT_BEFORE, (AFUNPTR)bbl_analysis_after,
                       IARG_PTR, basicBlockInfo, IARG_THREAD_ID, IARG_END);
    }
}
{%- endif %}
